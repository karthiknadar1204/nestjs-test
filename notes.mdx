1. npm i -g @nestjs/cli
2. nest -v
3. nest --help
4. nest new <project-name>
5. cd <project-name>
6. pnpm run start:dev
7. open http://localhost:3000

in nestjs project,each module is a compilation of folders mainly :
- middleware
- routes
- controllers
- services
so if we have a user module,all user related endpoints will be under the user module following the above structure.
refer to struct.png for more details.

in app.service.ts,we define the business logic for the app. the @injectable decorator is used to inject the service into the controller.
in app.controller.ts,we define the endpoints for the app. the @controller decorator is used to define the controller and the @get decorator is used to define the endpoint.
in app.module.ts,we define the modules for the app. the @module decorator is used to define the module and the @imports decorator is used to import the modules.
in main.ts,we bootstrap the app. the @nestfactory.create is used to create the app.


to create a module using cli,use the following command:
nest g module <module-name>

any new module created gets registered in the app.module.ts file,app.module.ts is the root module of the app.


TO create a controller using cli,use the following command:
nest g controller <controller-name>
-> we need to have a module first to create a controller.
@Controller('auth') basically means that /auth is the base url for all the endpoints in the controller.

to create a service using cli,use the following command:
nest g service/s <service-name>

to create a pipe using cli,use the following command:
nest g pipe <pipe-name>

to create a guard using cli,use the following command:
nest g guard <guard-name>
-> we need to have a module first to create a guard.

1) What is a constructor?
A constructor runs when you create an object. It sets up the object.

Simple example:
```typescript
// Without constructor (manual setup)
class Person {
  name: string;
}

const person = new Person();
person.name = "John"; // You have to set it manually

// With constructor (automatic setup)
class Person {
  constructor(name: string) {
    this.name = name; // Automatically sets name when created
  }
}

const person = new Person("John"); // Name is set automatically!
```

2) What does `private readonly` mean?
Breaking it down:

- `private`: Only this class can use it. Others can't access it.
- `readonly`: Can't change it after it's set (like a constant).

Simple example:
```typescript
class BankAccount {
  private balance: number = 100; // Only this class can see it
  readonly accountNumber: string = "12345"; // Can't change it
  
  getBalance() {
    return this.balance; // ✅ Can access it here (same class)
  }
}

const account = new BankAccount();
account.balance; // ❌ ERROR! Can't access private from outside
account.accountNumber = "99999"; // ❌ ERROR! Can't change readonly
```

3) Why use `private readonly` in the constructor?
This is a TypeScript shortcut that:
- Creates a property
- Makes it private
- Makes it readonly
- Assigns the value from the constructor parameter

Your code:
```typescript
constructor(private readonly authService: AuthService) {}
```

This is equivalent to:
```typescript
private readonly authService: AuthService;

constructor(authService: AuthService) {
  this.authService = authService;
}
```

4) What is dependency injection?
Instead of creating dependencies inside a class, you receive them from outside. NestJS handles this.

Bad way (without dependency injection):
```typescript
class AuthController {
  authService: AuthService;
  
  constructor() {
    // ❌ BAD: Creating the dependency yourself
    this.authService = new AuthService();
  }
}
```

Good way (with dependency injection):
```typescript
class AuthController {
  constructor(private readonly authService: AuthService) {
    // ✅ GOOD: NestJS gives you the service automatically!
  }
}
```

5) How NestJS does it
NestJS creates the service and passes it to the controller.

Step-by-step:
1. You register `AuthService` in the module (line 7 of `auth.module.ts`).
2. NestJS creates an instance of `AuthService`.
3. When creating `AuthController`, NestJS sees it needs `AuthService` in the constructor.
4. NestJS automatically passes the `AuthService` instance to the constructor.
5. You can use `this.authService` anywhere in the controller.

Visual example:
```typescript
// What YOU write:
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}
  
  register() {
    return this.authService.registerUser();
  }
}

// What NestJS does behind the scenes (simplified):
const authService = new AuthService(); // Step 1: Create service
const authController = new AuthController(authService); // Step 2: Pass it in
```

6) Why is this useful?
- Testable: Easy to swap in a fake service for testing.
- Flexible: Change the service implementation without changing the controller.
- Organized: Each class has a clear job.

Example:
```typescript
// Easy to test with a fake service
class FakeAuthService {
  registerUser() {
    return { message: 'Fake registration' };
  }
}

// In tests, you can do:
const controller = new AuthController(new FakeAuthService());
```


## Summary

**Your code:**
```typescript
constructor(private readonly authService: AuthService) {}
```

**What it means:**
1. `constructor(...)` = runs when the object is created
2. `private` = only this class can use `authService`
3. `readonly` = `authService` can't be changed after it's set
4. `authService: AuthService` = you're asking NestJS to give you an `AuthService`

**Why it's written this way:**
- NestJS automatically creates `AuthService` and passes it to your constructor
- You don't create it yourself; NestJS handles it
- This is called Dependency Injection

**Simple analogy:**
Instead of going to the kitchen to cook (creating the service yourself), you tell the waiter what you need (putting it in the constructor), and NestJS (the waiter) brings it to you automatically.


Modules are isolated from each other. only the services that are registered in the module can be used in the controller of the module.
we cannot use services from one module in another module.
except when using exports in the module.ts file.

now i have 2 modules auth and user,i want to use the code in my usermodule i.e userservice in a different module,so
i need to export the userservice in the user.module.ts file. in the exports"[] array we add the services that we want to export.
now in the auth.module.ts file we import the user.module.ts file and use the userservice in the auth.controller.ts file.
this is done using the imports"[] array in the auth.module.ts file.

basically service is exported from one module[user] and then imported in anohter module[auth] using imports"[] array as module.




To read environment variables,we use the following command:
pnpm add @nestjs/config

then in app.module.ts,in the imports"[] array we add the ConfigModule.forRoot() to read the environment variables.


guard is like a middleware that checks if the user is authenticated or not.
if the user is authenticated,the request is allowed to proceed.
if the user is not authenticated,the request is denied.

to create a guard,we use the following command:
nest g guard <guard-name>

then in the guard.ts file,we define the logic for the guard.

to use a guard,we add the guard to the controller using the @UseGuards decorator.